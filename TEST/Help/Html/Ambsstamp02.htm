<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>
<title> AM: Fondamenti del linguaggio SQL e l'istruzione SELECT in dettaglio</title>
<LINK rel=stylesheet type=text/css href="style_topic.css">
<SCRIPT LANGUAGE="JavaScript">
<!-- Begin
loadImage1 = new Image();
loadImage1.src = "../images/help_home_Button_01_Roll-over.gif";
staticImage1 = new Image();
staticImage1.src = "../images/help_home_Button_01_Roll-out.gif";

loadImage2 = new Image();
loadImage2.src = "../images/help_home_Button_02_Roll-over.gif";
staticImage2 = new Image();
staticImage2.src = "../images/help_home_Button_02_Roll-out.gif";

loadImage3 = new Image();
loadImage3.src = "../images/help_home_Button_03_Roll-over.gif";
staticImage3 = new Image();
staticImage3.src = "../images/help_home_Button_03_Roll-out.gif";

loadImage4 = new Image();
loadImage4.src = "../images/help_home_Button_04_Roll-over.gif";
staticImage4 = new Image();
staticImage4.src = "../images/help_home_Button_04_Roll-out.gif";

// End -->
</SCRIPT>

</head>
<body lang=it topMargin=3>
<TABLE border=0 width=987><TR><TD vAlign=top align=right><p><FONT size=2><CODE>Data ultimo aggiornamento: <A name=hINIeDATlAGGp></A>07/11/2012</FONT><A name=hFINeDATlAGGp></A></CODE></p></TD></TR></TABLE><TABLE border=0 cellSpacing=0><TR><TD colSpan=4><A href="http://www.ntsinformatica.it"><IMG border=0 alt="Clicca per accedere al sito di NTS Informatica" src="../images/help_home_banner.gif"></A></TD></TR></TABLE><TABLE border=0 cellSpacing=0 cellPadding=0><TR><TD align=left><A onmouseover="image1.src=loadImage1.src;" onmouseout="image1.src=staticImage1.src;" href="cose.htm"><IMG border=0 name=image1 alt="Clicca per accedere all'argomento" src="../images/help_home_Button_01_Roll-out.gif"></A></TD><TD align=middle><A onmouseover="image2.src=loadImage2.src;" onmouseout="image2.src=staticImage2.src;" href="pc.htm"><IMG border=0 name=image2 alt="Clicca per accedere all'argomento" src="../images/help_home_Button_02_Roll-out.gif"></A></TD><TD align=middle><A href="ambsargmod.htm"><IMG border=0 name=image3 alt="Clicca per accedere all'argomento" src="../images/help_home_Button_03_Roll-over.gif"></A></TD><TD align=right><A onmouseover="image4.src=loadImage4.src;" onmouseout="image4.src=staticImage4.src;" href="gaguidaan.htm"><IMG border=0 name=image4 alt="Clicca per accedere all'argomento" src="../images/help_home_Button_04_Roll-out.gif"></A></TD></TR><TR><TD colSpan=4><A href="http://www.ntsinformatica.it"><IMG border=0 alt="Clicca per accedere al sito di NTS Informatica" src="../images/help_home_Button_03_Roll-over-row.gif"></A></TD></TR><TR><TD bgColor=#009ee2 height=53 vAlign=center width=987 colSpan=4 align=left><p><FONT class=title color=white size=6><b>Fondamenti del linguaggio SQL e l'istruzione SELECT in dettaglio</b></FONT></p></TD></TR><TR><TD vAlign=center colSpan=4 align=left></TD></TR></TABLE><TABLE border=0 width=987><TR><TD><p>Il Linguaggio SQL, diventato ormai uno standard mondiale per formulare interrogazioni strutturate a database relazionali, incorpora molti costrutti (o istruzioni) oltre a quella principale denominata SELECT, ma per non divagare in discorsi che potrebbero risultare complessi se trattati in maniera approfondita, limiteremo la trattazione alla sola <I>istruzione di selezione</I>, rimandando l'utente che ne volesse sapere di più, alla consultazione di libri o manuali specifici su SQL, oppure su Microsoft Access.</p><p>L'istruzione SELECT (in italiano, SELEZIONA) permette di indicare a Business quali dati (Es.: Descrizione, Prezzo, Codice, Quantità, Data, etc.), relativi a una o più entità (Es.: Cliente, Articolo, Ordine, etc.), prelevare dagli archivi, se e come filtrarli (Es.: "solo quelli di Rimini" oppure "solo quelli che costano più di 10000 £", etc.), sulla base di quale dato presentarli in maniera ordinata e/o raggruppata. Di seguito ne è riportata la sintassi:</p><p>SELECT Nome<I>Campo1, NomeCampo2,....,NomeCampoN</I><br>FROM <I>NomeTabella</I><br>WHERE <I>Condizione</I><br>GROUP BY Nome<I>Campo1, NomeCampo2,....,NomeCampoL</I><br>HAVING <I>Condizione</I><br>ORDER BY Nome<I>Campo1,NomeCampo2,....,NomeCampoM</I></p><p>Supponiamo esistente una tabella, semplificata rispetto a quella esistente in Business, di nome <I>TbClienti</I> e contenente informazioni sui Clienti<I> e formata </I>dalle seguenti informazioni: <I>Cognome, Nome, Indirizzo, Cap, Città, Provincia, Telefono</I>.</p><p>Di seguito è riportato un possibile schema della tabella TbClienti:</p><p><b><A name=TbClienti>TbClienti</A></b></p><TABLE class=sample frame=box><TR vAlign=top><TD><b>Cognome</b></TD><TD><b>Nome</b></TD><TD><b>Indirizzo</b></TD><TD><b>Cap</b></TD><TD><b>Città</b></TD><TD><b>Provincia</b></TD><TD><b>Telefono</b></TD></TR><TR vAlign=top><TD>Rossi</TD><TD>Mario</TD><TD>Via Mimmo, 12</TD><TD>00100</TD><TD>Roma</TD><TD>RM</TD><TD>06/xxxxxx</TD></TR><TR vAlign=top><TD>Bianchi</TD><TD>Valerio</TD><TD>Via Mommi, 21</TD><TD>00?00</TD><TD>Milano</TD><TD>MI</TD><TD>02/yyyyyy</TD></TR><TR vAlign=top><TD>Verdi</TD><TD>Giuseppe</TD><TD>Via Rossini, 34</TD><TD>00800</TD><TD>Pesaro</TD><TD>PS</TD><TD>0721/zzzzzz</TD></TR><TR vAlign=top><TD>Blu</TD><TD>Marina</TD><TD>Via Rosa, 23</TD><TD>47036</TD><TD>Riccione</TD><TD>RN</TD><TD>0541/hhhhhh</TD></TR></TABLE><br><p>Ogni riga di questa tabella, eccetto la prima presente solo per motivi descrittivi, rappresenta un record (cioè un gruppo di informazioni relative alla stessa entità, nell'esempio "<I>un </I>Cliente") formato a sua volta da Campi (rappresentati nell'esempio dalle colonne, che specificano le informazioni disponibili per ogni record: Cognome, Nome, Indirizzo, Cap, Città, Provincia, Telefono). Fondamentalmente possiamo pensare gli archivi di Business molto prossimi a questa struttura (cioè una Tabella), con la differenza che il numero delle tabelle è di parecchie decine, e il numero di Campi per ogni tabella varia da 2 a 100 circa.</p><p>Una SELECT può essere vista come una operazione che prende in ingresso 1 o più tabelle, e ne restituisce una, contenente i risultati della nostra richiesta (Tabella Risultato). Creiamo, ora, una piccola Query (in italiano, INTERROGAZIONE; che non è altro che una istruzione SELECT): specifichiamo la parola chiave SELECT, seguita dal nome dei campi della tabella ( o Tabelle) che vogliamo siano visualizzati nella 'Tabella Risultato'.</p><p>SELECT <I>Cognome,Nome,Telefono</I></p><p>seguiti dalla clausola FROM (in italiano, Da) e il nome della o delle Tabelle a cui appartengono i campi elencati dopo la SELECT (fatto che rende importante conoscere la struttura delle tabelle del database di Business):</p><p>SELECT <I>Cognome,Nome,Telefono</I><br>FROM <I>TbClienti</I></p><p>Indicati quali campi vogliamo vedere e stabilite le tabelle a cui questi campi appartengono, abbiamo già fornito le indicazioni minime indispensabili per poter eseguire la query. Il risultato di questa query sarà una tabella ('Tabella Risultato') avente lo stesso numero di record (righe) della tabella TbClienti, ma solo 3 dei 7 campi della tabella TbClienti (abbiamo, cioè, limitato la visualizzazione di informazioni relative ad ogni cliente (riga) e NON, attenzione, al numero di clienti (righe) che rimane sempre 4) .</p><p>Ecco, di seguito, la 'Tabella Risultato' della query:</p><TABLE class=sample frame=box><TR vAlign=top><TD><b>Cognome</b></TD><TD><b>Nome</b></TD><TD><b>Telefono</b></TD></TR><TR vAlign=top><TD>Rossi</TD><TD>Mario</TD><TD>06/xxxxxx</TD></TR><TR vAlign=top><TD>Bianchi</TD><TD>Valerio</TD><TD>02/yyyyyy</TD></TR><TR vAlign=top><TD>Verdi</TD><TD>Giuseppe</TD><TD>0721/zzzzzz</TD></TR><TR vAlign=top><TD>Blu</TD><TD>Marina</TD><TD>0541/hhhhhh</TD></TR></TABLE><br><p>Supponiamo ora di voler vedere le stesse informazioni ma dei soli Clienti della provincia di Rimini:</p><p>SELECT <I>Cognome,Nome,Telefono</I><br>FROM <I>TbClienti</I><br>WHERE Provincia = 'RN'</p><p>Ed ecco il risultato di questa nuova query:</p><TABLE class=sample frame=box><TR vAlign=top><TD><b>Cognome</b></TD><TD><b>Nome</b></TD><TD><b>Telefono</b></TD></TR><TR vAlign=top><TD>Blu</TD><TD>Marina</TD><TD>0541/hhhhhh</TD></TR></TABLE><br><p>a tal fine abbiamo utilizzato la clausola WHERE (in italiano, Dove) attraverso cui possiamo indicare anche più condizioni (o filtri) nello stesso modo utilizzato per i <A href="bs--istp.htm">Filtri Utente</A>:</p><p>SELECT <I>Cognome,Nome,Telefono</I><br>FROM <I>TbClienti</I><br>WHERE Provincia = 'RN' OR Provincia = 'MI'</p><p>In questo caso, insieme ai Clienti della provincia di Rimini, verranno visualizzati nella 'Tabella Risultato' anche i clienti della provincia di Milano. (OR = oppure).</p><TABLE class=sample frame=box><TR vAlign=top><TD><b>Cognome</b></TD><TD><b>Nome</b></TD><TD><b>Telefono</b></TD></TR><TR vAlign=top><TD>Bianchi</TD><TD>Valerio</TD><TD>02/yyyyyy</TD></TR><TR vAlign=top><TD>Blu</TD><TD>Marina</TD><TD>0541/hhhhhh</TD></TR></TABLE><br><p>Se proviamo a leggere la query traducendo le sue clausole in italiano, notiamo che è un linguaggio abbastanza naturale dal punto di vista della comprensione: - <I>"SELEZIONA Cognome,Nome,Telefono DA TbClienti DOVE Provincia UGUALE 'RN' OPPURE Provincia UGUALE 'MI'"</I>.</p><p>Una istruzione di SELECT può, come abbiamo già detto, selezionare dati anche da più tabelle contemporaneamente. Facciamo un esempio, supponendo esistenti 2 tabelle così strutturate:</p><p><b><A name=TbDipendenti>TbDipendenti</A></b></p><TABLE class=sample frame=box><TR vAlign=top><TD><b>CodiceDipendente</b></TD><TD><b>Cognome</b></TD><TD><b>Nome</b></TD><TD><b>Stipendio</b></TD><TD><b>CodiceReparto</b></TD></TR><TR vAlign=top><TD><I>D1</I></TD><TD><I>Rossi</I></TD><TD><I>Mario</I></TD><TD><I>1.700.000</I></TD><TD><I>R1</I></TD></TR><TR vAlign=top><TD><I>D2</I></TD><TD><I>Verdi</I></TD><TD><I>Pino</I></TD><TD><I>1.800.000</I></TD><TD><I>R2</I></TD></TR><TR vAlign=top><TD><I>D3</I></TD><TD><I>Rosa</I></TD><TD><I>Maria</I></TD><TD><I>1.500.000</I></TD><TD><I>R1</I></TD></TR><TR vAlign=top><TD><I>D4</I></TD><TD><I>Bianchi</I></TD><TD><I>Barbara</I></TD><TD><I>2.000.000</I></TD><TD><I>R2</I></TD></TR></TABLE><br><p><b><A name=TbReparti>TbReparti</A></b></p><TABLE class=sample frame=box><TR vAlign=top><TD><b>CodiceReparto</b></TD><TD><b>Descrizione</b></TD><TD><b>Orario</b></TD><TD><b>CapoReparto</b></TD></TR><TR vAlign=top><TD>R1</TD><TD>Produzione</TD><TD>Intero</TD><TD>Pinco</TD></TR><TR vAlign=top><TD>R2</TD><TD>Controllo Q.</TD><TD>Ridotto</TD><TD>Pallino</TD></TR></TABLE><br><p>La Tabella TbDipendenti contiene il campo 'Codice del Dipendente', affinchè ogni dipendente sia univocamente identificato (anche in caso di omonimia), il campo 'Cognome', il campo 'Nome' e il campo 'Codice del Reparto' presso cui il Dipendente è impiegato. La Tabella TbReparti contiene il campo 'Codice del Reparto', il Campo 'Descrizione del Reparto', il campo 'Orario' e il campo 'Cognome del Capo-reparto'.</p><p>Proviamo a scrivere una query semplice:</p><p>SELECT TbDipendenti.Cognome, TbReparti.Descrizione, TbReparti.CapoReparto<br>FROM TbDipendenti, TbReparti</p><p>Riportiamo di seguito il risultato della query:</p><TABLE class=sample frame=box><TR vAlign=top><TD><b>TbDipendenti.Cognome</b></TD><TD><b>TbReparti.Descrizione</b></TD><TD><b>TbReparti.CapoReparto</b></TD></TR><TR vAlign=top><TD><I>Rossi</I></TD><TD>Produzione</TD><TD>Pinco</TD></TR><TR vAlign=top><TD><I>Verdi</I></TD><TD>Produzione</TD><TD>Pinco</TD></TR><TR vAlign=top><TD><I>Rosa</I></TD><TD>Produzione</TD><TD>Pinco</TD></TR><TR vAlign=top><TD><I>Bianchi</I></TD><TD>Produzione</TD><TD>Pinco</TD></TR><TR vAlign=top><TD><I>Rossi</I></TD><TD>Controllo Q.</TD><TD>Pallino</TD></TR><TR vAlign=top><TD><I>Verdi</I></TD><TD>Controllo Q.</TD><TD>Pallino</TD></TR><TR vAlign=top><TD><I>Rosa</I></TD><TD>Controllo Q.</TD><TD>Pallino</TD></TR><TR vAlign=top><TD><I>Bianchi</I></TD><TD>Controllo Q.</TD><TD>Pallino</TD></TR></TABLE><br><p>Premettiamo che il risultato potrebbe apparire poco significativo, in quanto il programma, che ha elaborato la nostra query, si è limitato, giustamente, a fornire tutte le combinazioni possibili dei record della tabella TbDipendenti con quelli della tabella TbReparti (il cliente 'Rossi' combinato prima con il Reparto 'Produzione' e poi col Reparto 'Controllo Q' e stessa cosa per i restanti 3 clienti), visualizzando poi solo i valori dei campi che noi abbiamo elencato di seguito alla parola chiave SELECT (TbDipendenti.Cognome, TbReparti.Descrizione, TbReparti.CapoReparto). I Record ritornati nella 'Tabella Risultato' sono 8, ottenuti, infatti, dai 4 della Tabella TbDipendenti combinati (quindi moltiplicati) con i 2 della Tabella TbReparti. Tecnicamente si dice che viene restituito il 'Prodotto Cartesiano' delle n Tabelle elencate nella clausola FROM.</p><p>Tenendo presente questo meccanismo, in base al quale ogni volta che nella clausola FROM (Da) appaiono due o più tabelle, il risultato sarà una combinazione di tutti i record della prima con tutti quelli della seconda, proviamo, immediatamente, a costruire una Query più significativa: supponiamo di voler sapere in che reparto lavora la Sig.ra Bianchi:</p><p>SELECT TbReparto.CodiceReparto, TbReparto.Descrizione<br>FROM TbDipendenti, TbReparti<br>WHERE TbDipendenti.Cognome="Bianchi" AND TbDipendenti.CodiceReparto = TbReparti.CodiceReparto</p><p>Di seguito è riportato il risultato della query appena descritta:</p><TABLE class=sample frame=box><TR vAlign=top><TD><b>TbReparto.CodiceReparto</b></TD><TD><b>TbReparto.Descrizione</b></TD></TR><TR vAlign=top><TD>R2</TD><TD>Controllo Q.</TD></TR></TABLE><br><p>I campi riportati sono due (TbReparto.CodiceReparto, TbReparto.Descrizione), perché due sono i campi listati di seguito alla istruzione SELECT. Da notare che al nome dei campi (CodiceReparto, Descrizione) è stato fatto precedere il nome della tabella separata da un punto("TbReparto."), per evitare errori qualora ci siano campi con nomi uguali, appartenenti a tabelle diverse (come nel nostro caso con CodiceReparto, presente in entrambe le tabelle TbReparti e TbDipendenti). Si consiglia di utilizzare sempre questa convenzione. Nella clausola FROM (Da), invece, troviamo elencati i nome delle due tabelle, anche se non richiediamo alcuna visualizzazione dei campi della tabella TbDipendenti; ciò perché abbiamo bisogno di avere tutte le combinazioni fra le due tabelle, come nell'esempio precedente, da cui, poi, selezionare solo quelle che ci interessano ai fini dell'ottenimento del risultato che ci aspettiamo. Infatti per poter selezionare i soli dati relativi alla Signora Bianchi, abbiamo specificato che il campo Cognome, che è un campo di TbDipendenti, deve essere uguale a "Bianchi" (quindi, saranno scartate tutte le combinazioni NON aventi nel campo TbDipendenti.Cognome il valore 'Bianchi'). La seconda condizione, unita alla prima tramite l'operatore logico "AND", viene tecnicamente chiama "JOIN" cioè "Collegamento". è, infatti, quest'ultima, che ci permette di visualizzare la Descrizione associata al CodiceReparto 'R2' che è il valore presente anche, nel campo CodiceReparto del record relativo alla Signora 'Bianchi' nella tabella TbDipendenti. Possiamo dire, in altre parole, che la Join "collega" i dati della tabella TbDipendenti con i relativi e corrispondenti dati della TbReparti (costringe, cioè, il motore SQL a scartare tutte quelle combinazioni di record delle due tabelle in cui NON si ha che il CodiceReparto di TbDipendenti sia UGUALE al CodiceReparto di TbReparti).</p><p>Proviamo, ora, a richiedere Nome e Cognome di tutti i dipendenti che lavorano nel reparto 'Produzione'.</p><p>SELECT TbDipendenti.Cognome, TbDipendenti.Nome<br>FROM TbDipendenti, TbReparti<br>WHERE TbReparti.Descrizione = 'Produzione' AND TbDipendenti.CodiceReparto = TbReparti.CodiceReparto</p><p>Quanto segue, ne costituisce il risultato:</p><TABLE class=sample frame=box><TR vAlign=top><TD><b>TbDipendenti.Cognome</b></TD><TD><b>TbDipendenti.Nome</b></TD></TR><TR vAlign=top><TD><I>Rossi</I></TD><TD><I>Mario</I></TD></TR><TR vAlign=top><TD><I>Rosa</I></TD><TD><I>Maria</I></TD></TR></TABLE><br><p>Nella SELECT è stato richiesto il contenuto dei campi Cognome e Nome della tabella TbDipendenti. Nella Clausola FROM (Da) sono state nuovamente specificate entrambe le tabelle, affinchè il programma esegua il 'Prodotto Cartesiano' tra le tabelle in questione. Nella Clausola WHERE (Dove) troviamo la solita JOIN (collegamento), che collega la tabella TbDipendenti con la tabella TbReparti attraverso il campo CodiceReparto (ma che praticamente non è altro che la condizione che scarta tutte le combinazioni in cui TbDipendenti.CodiceReparto e TbReparti.CodiceReparto sono diversi), e la condizione che impone la selezione di tutte e solo le combinazioni di record che hanno nel campo TbReparti.Descrizione il valore 'Produzione'.</p><p>Se alla query precedente aggiungiamo la clausola ORDER BY (in italiano, ORDINATE PER), è possibile variare l'ordine di visualizzazione dei record nella 'Tabella Risultato'. Es.:</p><p>SELECT TbDipendenti.Cognome, TbDipendenti.Nome<br>FROM TbDipendenti, TbReparti<br>WHERE TbReparti.Descrizione = 'Produzione' AND TbDipendenti.CodiceReparto = TbReparti.CodiceReparto<br>ORDER BY TbDipendenti.Cognome, TbDipendenti.Nome</p><p>In questo modo la 'Tabella Risultato' sarà ordinata in base al campo Cognome, e in caso di uguaglianza del campo Cognome, in base al campo Nome e in caso di uguaglianza anche del Campo Nome, in ordine di disposizione nelle tabelle di origine (TbDipendenti).</p><TABLE class=sample frame=box><TR vAlign=top><TD><b>TbDipendenti.Cognome</b></TD><TD><b>TbDipendenti.Nome</b></TD></TR><TR vAlign=top><TD><I>Rosa</I></TD><TD><I>Maria</I></TD></TR><TR vAlign=top><TD><I>Rossi</I></TD><TD><I>Mario</I></TD></TR></TABLE><br><p>L'ultima Clausola applicabile, è quella denominata GROUP BY (in italiano, RAGGRUPPATI PER). Essa ci permette di raggruppare i record (righe) in base a campi che hanno gli stessi valori e attraverso la sotto-clausola HAVING (in Italiano, AVENTI) eliminare i raggruppamenti che non ci interessano. In altre parole, occorre utilizzare la clausola WHERE (Dove) per escludere le righe che non si desidera raggruppare e occorre utilizzare la clausola HAVING (Aventi) per filtrare i record dopo che sono stati raggruppati.Es:</p><p>SELECT TbReparti.Descrizione, SUM(TbDipendenti.Stipendio)<br>FROM TbDipendenti, TbReparti<br>WHERE TbDipendenti.CodiceReparto = TbReparti.CodiceReparto<br>GROUP BY TbReparti.Descrizione</p><p>Attraverso la Query precedente si ottiene, un raggruppamento dei dipendenti per reparto di lavoro e attraverso la funzione SUM(stipendio) si ottiene la somma degli stipendi dei dipendenti raggruppati per reparto. Le funzioni tipo SUM (Avg, Count, Min, Max) non sono attualmente inseribili tramite il Generatore di Query. Nell'eventualità, è lasciato all'utente il compito di inserirlo manualmente.</p><TABLE class=sample frame=box><TR vAlign=top><TD><b>TbReparti.Descrizione</b></TD><TD><b>SUM(stipendio)</b></TD></TR><TR vAlign=top><TD>Controllo Q.</TD><TD>3.800.000</TD></TR><TR vAlign=top><TD>Produzione</TD><TD>3.200.000</TD></TR></TABLE><br><p>La sintassi delle condizioni inseribili nella clausola HAVING (Aventi) rispondono alle stesse regole delle condizioni della clausola WHERE (Dove), con la differenza che possono essere oggetto di condizione solo i Campi elencati dopo la Clausola GROUP BY (Raggruppati per).</p></TD></TR></TABLE><TABLE border=0 cellSpacing=0 cellPadding=0><TR><TD vAlign=center width=168 align=middle><A href="http://www.ntsinformatica.it/software-erp-medie-imprese/software-erp/software-retail-negozi/"><IMG border=0 src="../images/help_home_01_Gestisci.gif"></A></TD><TD vAlign=center width=168 align=middle><A href="http://www.ntsinformatica.it/software-erp-medie-imprese/software-erp/controllo-di-gestione/"><IMG border=0 src="../images/help_home_02_Controlla.gif"></A></TD><TD vAlign=center width=168 align=middle><A href="http://www.ntsinformatica.it/software-erp-medie-imprese/software-erp/crm/"><IMG border=0 src="../images/help_home_03_Fidelizza.gif"></A></TD><TD vAlign=center width=168 align=middle><A href="http://www.ntsinformatica.it/software-erp-medie-imprese/software-erp/analisi-dati-datawarehouse/"><IMG border=0 src="../images/help_home_04_DWH.gif"></A></TD><TD vAlign=center width=169 align=middle><A href="http://www.ntsinformatica.it/software-erp-medie-imprese/software-erp/project-management/"><IMG border=0 src="../images/help_home_05_Gestisci.gif"></A></TD><TD vAlign=center width=146 align=right><IMG border=0 src="../images/help_home_NTS_logo_up.gif"></TD></TR><TR><TD vAlign=center width=168 align=middle><A href="http://www.ntsinformatica.it/software-erp-medie-imprese/software-erp/logistica/"><IMG border=0 src="../images/help_home_06_Organizza.gif"></A></TD><TD vAlign=center width=168 align=middle><A href="http://www.ntsinformatica.it/software-erp-medie-imprese/software-erp/customer-service/"><IMG border=0 src="../images/help_home_07_Gestisci.gif"></A></TD><TD vAlign=center width=168 align=middle><A href="http://www.ntsinformatica.it/software-erp-medie-imprese/software-erp/produzione/"><IMG border=0 src="../images/help_home_08_Pianifica.gif"></A></TD><TD vAlign=center width=168 align=middle><A href="http://www.ntsinformatica.it/software-erp-medie-imprese/software-erp/archiviazione-documenti/"><IMG border=0 src="../images/help_home_09_Archivia.gif"></A></TD><TD vAlign=center width=169 align=right><IMG border=0 src="../images/help_home_NTS_logo_down1.gif"></TD><TD vAlign=center width=146 align=right><A href="http://www.ntsinformatica.it"><IMG border=0 alt="Clicca per accedere al sito di NTS Informatica" src="../images/help_home_NTS_logo_down2.gif"></A></TD></TR><TR><TD width=987 colSpan=6><IMG border=0 src="../images/help_home_Line.gif"></TD></TR></TABLE></body></html>